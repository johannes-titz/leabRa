<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Johannes Titz" />

<meta name="date" content="2017-09-12" />

<title>LeabRa: Biologically realistic neural networks based on Leabra in R</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">LeabRa: Biologically realistic neural networks based on Leabra in R</h1>
<h4 class="author"><em>Johannes Titz</em></h4>
<h4 class="date"><em>2017-09-12</em></h4>



<p>This package provides the Leabra artifical neural network algorithm for R. Leabra stands for “local error driven and associative biologically realistic algorithm”. It is the Rolls Royce of artifical neural networks because it combines error driven learning and self organized learning in an elegant way, while focusing on a biologically plausible learning rule. If you have never heard of Leabra, you should read about it first. A good place to start is the computational cognitive neuroscience book (Part I): <a href="https://grey.colorado.edu/CompCogNeuro/index.php/CCNBook/Main" class="uri">https://grey.colorado.edu/CompCogNeuro/index.php/CCNBook/Main</a> (O’Reilly et al., 2016).</p>
<p>This version of Leabra is rather slow compared to the original implementation in C++. It was not intended for constructing large networks or running many trials; unless you do not care about processing resources. The main purpose of this implementation is to quickly try out new ideas; either in constructing new networks or in changing the algorithm to achieve certain outcomes. If you would want to do this with the C++ version, you would have to deal with optimized code, that is probably harder to read. Note that the Matlab version by Sergio Verduzuco-Flores (there is a short reference to it on this website: <a href="https://grey.colorado.edu/emergent/index.php/Leabra" class="uri">https://grey.colorado.edu/emergent/index.php/Leabra</a>) has the same purpose and I recommend to try it out and read his great documentation. Actually his version was the template for this package and many things are written identically. Unfortunately, Matlab is non-free (in the libre sense), so I believe that this R version is the easiest way to get familiar with Leabra quickly. This is especially true for psychologists, who are usually acquainted with R anway and might want to “wrangle” with the data in their programming mother tongue.</p>
<p>What follows is a brief introduction for constructing networks with this package. The first network will be a pattern associator; it associates a specific input with a specific output in an error-driven fashion through a hidden layer. The second network will be a self-organized network that tries to categorize animals represented by feature vectors.</p>
<div id="pattern-associator" class="section level2">
<h2>Pattern Associator</h2>
<p>You might say, that associating two patterns is unspectacular, because this can be achieved easily by back-propagating errors (Rumelhart et al., 1986). But Leabra uses a much more sophisticated learning rule, which is biologically oriented. In essence, you first present the input without the correct output. After that, you present the input <em>and</em> the correct output. Now, the weights are changed in such a way that the next time you present the input, the activation in the output will be more similar to the correct output. Changing weights is done completely <em>locally</em>; only the activations of the neurons over different time frames (short, medium and long term) are used to achieve this. Pretty impressive, right?</p>
<p>I think of it as if I wanted to learn a new foreign language vocabulary or geography. For instance, I want to associate the country Burkina Faso with its capital Ouagadougou (spelled [waga’du:gu]). In the first phase only Burkina Faso is presented and the neuronal network in my brain will try to produce the correct output Ouagadougou. It will likely not succeed in the beginning, maybe something similar will be output, but not the correct city. After this phase Burkina Faso and Ouagadougou are presented at the same time. Now, the spreading of activation will be correct. After these two phases the weights are changed, such that the next time I see Burkina Faso the output will be more similar to Ouagadougou. This adjustment happens by just looking at how active the units were over short, medium and long time frames.</p>
<div id="constructing-the-network" class="section level3">
<h3>Constructing the Network</h3>
<p>Let us load the package</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(leabRa)</code></pre></div>
<p>To reproduce the example we can use a seed. You can try to guess whose birthday is on July 22nd, 1904.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">07221904</span>)</code></pre></div>
<p>To construct a network, we will at least need the dimensions of the network and the connections between the layers. We will specify three layers: input – hidden – output. They are quite small, so that the calculations do not take too long.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dim_lays &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">10</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">5</span>))</code></pre></div>
<p>Let us now specify the connections between these layers. Layer 1 (input) should be connected with layer 2 (hidden). Layer 3 (output) will be bidirectionally connected with layer 2. If layer j sends projections to layer i, then connections[i, j] = strength &gt; 0 and 0 otherwise. Strength specifies the relative strength of that connection with respect to the other projections to layer i. More intuitvely, just look at the rows and you will see that row (layer) 2 receives from columns (layers) 1 and 3; the connection with layer 1 is 5 times stronger (<span class="math inline">\(0.2 \cdot 5 = 1\)</span>) than the connection with layer 3. Furthermore, row (layer) 3 receives from column (layer) 2.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">connections &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
                        <span class="dv">1</span>, <span class="dv">0</span>, <span class="fl">0.2</span>,
                        <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>), <span class="dt">nrow =</span> <span class="dv">3</span>, <span class="dt">byrow =</span> T)</code></pre></div>
<p>Note that in the current version of the package layers are either fully connected or unconnected. If you need partially connected layers, you will need to add this functionality on your own.</p>
<p>Now, we will create a network with default parameters.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">net &lt;-<span class="st"> </span>network<span class="op">$</span><span class="kw">new</span>(dim_lays, connections)</code></pre></div>
<p>The package is an R6 package, a special type of object oriented programming that behaves differently to the usual R object oriented programming style. You can see this, because we call the method of a class with the dollar sign (network<strong>$</strong>new(…)) instead of using a generic function. Furthermore, variables are also accessed via the dollar sign instead of the at-sign @.</p>
<p><em>dim_lays</em> and <em>connections</em> is the minimum you need to specify a network, but if constructing other networks you should pay careful attention to <em>g_i_gain</em>, which controls overall inhibition in a layer (inhibitory condutance gain). If this value is not set carefully, you might not get what you want (too much or not enough activation).</p>
</div>
<div id="creating-input-patterns" class="section level3">
<h3>Creating Input Patterns</h3>
<p>Now, we have a network, but no inputs. Let us create 15 random patterns with the method <em>create_inputs</em> in the network class. We want random patterns in layer 1 and 3, that are supposed to be associated during learning. We call these inputs inputs_plus, because this is what is presented to the network during the plus phase (correct output in layer 3 is presented). <em>prop_active</em> is the amount of active units in the patterns, activation is either 0.05 or 0.95. We choose .3, meaning that on average 30% of units will have an activation 0.95 and 70% an activation of 0.05.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">inputs_plus &lt;-<span class="st"> </span>net<span class="op">$</span><span class="kw">create_inputs</span>(<span class="dt">which_layers =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>),
                                 <span class="dt">n_inputs =</span> <span class="dv">15</span>,
                                 <span class="dt">prop_active =</span> .<span class="dv">3</span>)</code></pre></div>
<p>You could also create inputs with your own functions. The network will accept an external input list that has the length of the number of layers. Every element in the list should have the actviation values of the neurons for the specific layer.</p>
<p>For error-driven learning in Leabra fashion, we will need to remove the inputs of the output layer (layer 3) for the minus phase. We will call this list inputs_minus (the correct output is missing, it was subtracted). Functionals are neat, so we will use lapply here:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">inputs_minus &lt;-<span class="st"> </span><span class="kw">lapply</span>(inputs_plus, <span class="cf">function</span>(x) {x[<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="ot">NULL</span>); <span class="kw">return</span>(x)})</code></pre></div>
</div>
<div id="learning" class="section level3">
<h3>Learning</h3>
<p>Now we can start learning with default parameters. The return value of the learning function is the output activation after each trial before the weights are changed. This way we can save resources, because we do not have to test the inputs again after learning. The first epoch will be kind of baseline of each stimulus. In the next step we will use the output activtions to calculate the error. During learning, the progress is reported by dots that represent a single trial. This means that minus, plus phase and weight changing has been performed for one stimulus. Every row is a new epoch. Epoch is a term in Leabra to describe that all stimuli were presented once.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n_epochs &lt;-<span class="st"> </span><span class="dv">10</span>
outs &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="kw">seq</span>(n_epochs), <span class="cf">function</span>(x) net<span class="op">$</span><span class="kw">learn_error_driven</span>(inputs_minus,
                                                                 inputs_plus))<span class="co">#,</span></code></pre></div>
<pre><code>## ...............
## ...............
## ...............
## ...............
## ...............
## ...............
## ...............
## ...............
## ...............
## ...............</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">                                                                 <span class="co">#lrate = 0.5))</span></code></pre></div>
</div>
<div id="plotting-results" class="section level3">
<h3>Plotting Results</h3>
<p>The network class can calculate the mean absolute deviation (MAD) for each epoch. You can also use your own functions on these lists to calculate other types of errors like the cosine error. We will need the error for layer 3 (output).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mad &lt;-<span class="st"> </span>net<span class="op">$</span><span class="kw">mad_per_epoch</span>(outs, inputs_plus, <span class="dv">3</span>)</code></pre></div>
<p>How about a nice minimalistic plot to see if it worked?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(mad, <span class="dt">axes =</span> F, <span class="dt">pch =</span> <span class="dv">16</span>, <span class="dt">family =</span> <span class="st">&quot;serif&quot;</span>, <span class="dt">type =</span> <span class="st">&quot;b&quot;</span>,
     <span class="dt">xlab =</span> <span class="st">&quot;epoch [#]&quot;</span>,
     <span class="dt">ylab =</span> <span class="st">&quot;mean absolute deviation [activation]&quot;</span>,
     <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="kw">min</span>(mad), <span class="kw">max</span>(mad)))
<span class="kw">axis</span>(<span class="dv">1</span>, <span class="dt">at =</span> <span class="kw">seq</span>(<span class="kw">length</span>(mad)), <span class="dt">tick =</span> T, <span class="dt">family =</span> <span class="st">&quot;serif&quot;</span>)
<span class="kw">axis</span>(<span class="dv">2</span>, <span class="dt">at =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.05</span>), <span class="dt">labels =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.05</span>), <span class="dt">tick =</span> T,
     <span class="dt">family =</span> <span class="st">&quot;serif&quot;</span>, <span class="dt">las =</span> <span class="dv">2</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>The error gets smaller with each epoch, so the pattern associator seems to work just fine.</p>
</div>
<div id="some-additional-notes" class="section level3">
<h3>Some Additional Notes</h3>
<p>You can influence how many cycles should be run during the minus and plus phase, which are parameters for the <em>learn_error_driven</em> method. Besides, you could also implement your own functions to learn. Internally the <em>learn_error_driven</em> method is straightforward. It just use the method <em>cycle</em> to clamp the external input activations and to get the internal inputs from other layers. This is done several times for the minus phase (e.g. 50 times by default) and then for the plus phase (e.g. 25 times by default). After that the method <em>chg_wt</em> is called to adjust the weights. This procedure is repeated for every stimulus.</p>
<p>If you want to modify the initial weight matrix you have some options. When creating the network you can specify a function to create a random weight. The default function is:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">w_init_fun =<span class="st"> </span><span class="cf">function</span>(x) <span class="fl">0.3</span> <span class="op">+</span><span class="st"> </span><span class="fl">0.4</span> <span class="op">*</span><span class="st"> </span><span class="kw">runif</span>(x)</code></pre></div>
<p>It produces weights between 0.3 and 0.7 from a uniform distribution. Let us say, you want to generate weights from a normal distribution with a mean of 0.6 and a standard deviation of 0.1. You could specify the <em>w_init_fun</em> accordingly when constructing a new network object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">net &lt;-<span class="st"> </span>network<span class="op">$</span><span class="kw">new</span>(dim_lays, connections, <span class="dt">w_init_fun =</span> <span class="cf">function</span>(x) <span class="kw">rnorm</span>(x, <span class="dt">mean =</span> <span class="fl">0.6</span>, <span class="dt">sd =</span> <span class="fl">0.1</span>))</code></pre></div>
<p>This might not be enough flexibility, so you can also create your own weight_matrix from scratch and just pass it as the parameter <em>w_init</em>, the initial weight matrix. <em>w_init</em> is a matrix of matrices (like a cell array in matlab), so pay attention when you create it from scratch.</p>
<p>This package uses R6 classes, meaning that you do not have to assign objects in the usual R way. For instance calling net$learn_error_driven above, actually modified the net object, although we did not make any explicit assignment. This is unusual for R and has some disadvantages, but it is faster and uses less resources (ideal for a simulation) than the more common S3/S4 classes. Just pay attention when you call methods in this package. They will modify objects in place.</p>
</div>
</div>
<div id="hello-world-in-connectionism-categorizing-animals" class="section level2">
<h2>Hello World in “Connectionism”: Categorizing Animals</h2>
<p>Every time I get familiar with a neural network software, I try to create some typical examples. Certainly, one is the pattern associator. For me, another one is the example by Knight (1990) for unsupervised (self-organized) learning of animals. This is kind of my “hello world” for artifical neural networks.</p>
<p>Again, let us set a seed, so you can reproduce the example.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">22071904</span>)</code></pre></div>
<p>We will start with the input patterns, because the network architecture depends on the dimension of these patterns.</p>
<div id="input-patterns" class="section level3">
<h3>Input Patterns</h3>
<p>The inputs for the network are animals represented by features that are either present or absent (Knight, 1990, p. 71). This data comes directly with the leabRa package and is called <em>animals</em>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">animals</code></pre></div>
<pre><code>##           has.hair has.scales has.feathers flies lives.in.water lays.eggs
## dog              1          0            0     0              0         0
## cat              1          0            0     0              0         0
## bat              1          0            0     1              0         0
## whale            1          0            0     0              1         0
## canary           0          0            1     1              0         1
## robin            0          0            1     1              0         1
## ostrich          0          0            1     0              0         1
## snake            0          1            0     0              0         1
## lizard           0          1            0     0              0         1
## alligator        0          1            0     0              1         1</code></pre>
<p>Because the network class at the moment only accepts a list as external inputs, we transform the data frame rows to elements of a list.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">inputs &lt;-<span class="st"> </span>plyr<span class="op">::</span><span class="kw">alply</span>(animals, <span class="dv">1</span>)</code></pre></div>
<p>Furthermore we will need an empty list element (NULL) for the second layer.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">inputs &lt;-<span class="st"> </span><span class="kw">lapply</span>(inputs, <span class="cf">function</span>(x) <span class="kw">list</span>(x, <span class="ot">NULL</span>))</code></pre></div>
<p>This is what I meant, when I wrote that R people might prefer wrangling with the data in their mother tongue.</p>
</div>
<div id="network-architecture" class="section level3">
<h3>Network Architecture</h3>
<p>We will use a 2-layer network, where layer 2 receives from layer 1. The size of layer 1 must be 6, because there are 6 features for representing an animal. The size of layer 2 is 3, meaning that the inputs will be categorized into three groups. You can experiment with the number of units in layer 2 to get other categories.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dim_lays &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">6</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">1</span>))
connections &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>,
                        <span class="dv">1</span>, <span class="dv">0</span>), <span class="dt">nrow =</span> <span class="dv">2</span>, <span class="dt">byrow =</span> T)</code></pre></div>
</div>
<div id="learning-1" class="section level3">
<h3>Learning</h3>
<p>We want to run the simulation not just once, but several times. We can go for 10 times, because the network is small. To achieve this we can write a short function that initializes the network and then learns self-organized. After learning we will test how it reacts to the inputs with the method <em>test_inputs</em> (changing weights is turned off in this method). Compared to the network before, we need to do this, because we only run one epoch per simulation. The network will be different for each simulation, because the weights are initialized randomly. You can think of this procedure as if you would let 10 participants observe ten different animals. The difference in participants is mimicked in the different weight matrices for every network.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">run_sim &lt;-<span class="st"> </span><span class="cf">function</span>(dim_lays, connections, inputs){
  net &lt;-<span class="st"> </span>network<span class="op">$</span><span class="kw">new</span>(dim_lays, connections)
  net<span class="op">$</span><span class="kw">learn_self_organized</span>(inputs)
  net<span class="op">$</span><span class="kw">test_inputs</span>(inputs)
}</code></pre></div>
<p>Now we can run the simulation. 10 runs should not be a problem, because the network is tiny. In the vignette the messages for the next code chunk were turned off to not clutter this document with the progress bar.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n_runs &lt;-<span class="st"> </span><span class="dv">10</span>
outs &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="kw">seq</span>(n_runs), <span class="cf">function</span>(x) <span class="kw">run_sim</span>(dim_lays, connections, inputs))</code></pre></div>
<pre><code>## ..........
## ..........
## ..........
## ..........
## ..........
## ..........
## ..........
## ..........
## ..........
## ..........</code></pre>
</div>
<div id="plotting-results-1" class="section level3">
<h3>Plotting Results</h3>
<p>The output is the activations of each layer after all stimuli were presented. We are only interested in layer 2, so let us extract these activations and transform them to data frames (some “wrangling” again). We can then look at the outputs of two simulation runs to get a feeling whether it works.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">outs_layer_two &lt;-<span class="st"> </span><span class="kw">lapply</span>(outs, <span class="cf">function</span>(x) <span class="kw">lapply</span>(x, <span class="cf">function</span>(y) y[[<span class="dv">2</span>]]))
outs_layer_two &lt;-<span class="st"> </span><span class="kw">lapply</span>(outs_layer_two, <span class="cf">function</span>(x) <span class="kw">do.call</span>(rbind, x))
outs_layer_two &lt;-<span class="st"> </span><span class="kw">lapply</span>(outs_layer_two, round, <span class="dv">2</span>)
<span class="kw">round</span>(outs_layer_two[[<span class="dv">1</span>]], <span class="dv">2</span>)</code></pre></div>
<pre><code>##    [,1] [,2] [,3]
## 1  0.00 0.89    0
## 2  0.00 0.89    0
## 3  0.00 0.62    0
## 4  0.00 0.94    0
## 5  0.87 0.00    0
## 6  0.87 0.00    0
## 7  0.70 0.08    0
## 8  0.65 0.00    0
## 9  0.65 0.00    0
## 10 0.13 0.35    0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">round</span>(outs_layer_two[[<span class="dv">4</span>]], <span class="dv">2</span>)</code></pre></div>
<pre><code>##    [,1] [,2] [,3]
## 1  0.00 0.87 0.00
## 2  0.00 0.87 0.00
## 3  0.00 0.87 0.00
## 4  0.77 0.00 0.00
## 5  0.27 0.00 0.54
## 6  0.27 0.00 0.54
## 7  0.22 0.00 0.56
## 8  0.00 0.00 0.94
## 9  0.00 0.00 0.94
## 10 0.00 0.00 0.96</code></pre>
<p>Overall, this result looks reasonable. The output units fight for activation, such that only one unit is active most of the time. This is the category of the animal and it seems to work: recall, that the first 4 animals were dog, cat, bat and whale, they are similar. One problem we can see here is that for some simulations only 2 output units are active, the third is never active. This happens because of hogging, a problem that often occurs in self organized learning. One output unit is so strong, that it attracts everything; in our case two units are much stronger than the third one. There are couple of ways to deal with hogging (see <a href="https://grey.colorado.edu/emergent/index.php/Leabra" class="uri">https://grey.colorado.edu/emergent/index.php/Leabra</a>), but for our simple example we can ignore it, because we run several simulations, so it is not an issue if a couple of them have hogging units.</p>
<p>Certainly, there are many ways to work with these activations. For instance, we can calculate the distance (or similarity) between the ten animals in their output activation and then run a cluster analysis or draw a heatmap. But a critic might say, that this allows for too much degrees of freedom. The output units can have activations between 0 and 1 and there are three of them. Maybe the 6 binary features will just be mapped onto three units, that have a wide range of possible values. This might not really impressive. We can take a more rigorous cognitive approach: If asking a human about an animal, he or she will take a clear decision in which category to put the animal. Sometimes this can be a close decision, but this will be reflected by different simulation runs through random weights.</p>
<p>Let us transform the matrices to 1 and 0, the maximum value will get 1 and the other ones will get 0. This is a clear-cut decision where to put an animal. We will use a short function for this, that is applied on every row of every output matrix.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">apply_threshold_on_row &lt;-<span class="st"> </span><span class="cf">function</span>(row){
  row[<span class="op">-</span><span class="kw">which.max</span>(row)] &lt;-<span class="st"> </span><span class="dv">0</span>
  row[<span class="kw">which.max</span>(row)] &lt;-<span class="st"> </span><span class="dv">1</span>
  row
}

outs_layer_two &lt;-<span class="st"> </span><span class="kw">lapply</span>(outs_layer_two,
                         <span class="cf">function</span>(x) <span class="kw">t</span>(<span class="kw">apply</span>(x, <span class="dv">1</span>, apply_threshold_on_row)))

<span class="kw">round</span>(outs_layer_two[[<span class="dv">1</span>]], <span class="dv">2</span>)</code></pre></div>
<pre><code>##    [,1] [,2] [,3]
## 1     0    1    0
## 2     0    1    0
## 3     0    1    0
## 4     0    1    0
## 5     1    0    0
## 6     1    0    0
## 7     1    0    0
## 8     1    0    0
## 9     1    0    0
## 10    0    1    0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># lost_to_zero &lt;- function(matrix){</span>
<span class="co">#   t(apply(matrix, 1, function(x) {x[-which.max(x)] &lt;- 0; x}))</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># won_to_one &lt;- function(matrix){</span>
<span class="co">#   t(apply(matrix, 1, function(x) {x[which.max(x)] &lt;- 1; x}))</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># outs_layer_two &lt;- lapply(outs_layer_two, set_won)</span>
<span class="co"># outs_layer_two &lt;- lapply(outs_layer_two, set_won2)</span></code></pre></div>
<p>Now, we want to know which animals are grouped together. Here we will just take shortcut. We can calculate the distance matrix for every simulation. Because of the thresholding from above, we know the euclidian distance between two animals is either 0 if they belong to the same category or <span class="math inline">\(\sqrt(2)\)</span> if they do not, so we will just transform <span class="math inline">\(\sqrt(2)\)</span> to 1 and then we know which animals belong together.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dists &lt;-<span class="st"> </span><span class="kw">lapply</span>(outs_layer_two, dist)
dists &lt;-<span class="st"> </span><span class="kw">lapply</span>(dists, <span class="cf">function</span>(x) {x[x <span class="op">!=</span><span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="dv">1</span>; x})
dists[[<span class="dv">1</span>]]</code></pre></div>
<pre><code>##    1 2 3 4 5 6 7 8 9
## 2  0                
## 3  0 0              
## 4  0 0 0            
## 5  1 1 1 1          
## 6  1 1 1 1 0        
## 7  1 1 1 1 0 0      
## 8  1 1 1 1 0 0 0    
## 9  1 1 1 1 0 0 0 0  
## 10 0 0 0 0 1 1 1 1 1</code></pre>
<p>So here animals 2, 3, 4 and 10 are in one category and the rest in the other. But this is only 1 distance matrix, we have 10 of them; this is just too much information. We can average these values over the simulation runs by using a neat functional again:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dists_mtrx &lt;-<span class="st"> </span><span class="kw">lapply</span>(dists, as.matrix)
mean_dists &lt;-<span class="st"> </span><span class="kw">Reduce</span>(<span class="st">&quot;+&quot;</span>, dists_mtrx) <span class="op">/</span><span class="st"> </span><span class="kw">length</span>(dists)
mean_dists</code></pre></div>
<pre><code>##      1   2   3   4   5   6   7   8   9  10
## 1  0.0 0.0 0.4 0.3 0.7 0.7 0.6 0.9 0.9 0.6
## 2  0.0 0.0 0.4 0.3 0.7 0.7 0.6 0.9 0.9 0.6
## 3  0.4 0.4 0.0 0.5 0.6 0.6 0.7 0.9 0.9 0.7
## 4  0.3 0.3 0.5 0.0 0.7 0.7 0.6 0.9 0.9 0.6
## 5  0.7 0.7 0.6 0.7 0.0 0.0 0.2 0.4 0.4 0.5
## 6  0.7 0.7 0.6 0.7 0.0 0.0 0.2 0.4 0.4 0.5
## 7  0.6 0.6 0.7 0.6 0.2 0.2 0.0 0.3 0.3 0.4
## 8  0.9 0.9 0.9 0.9 0.4 0.4 0.3 0.0 0.0 0.3
## 9  0.9 0.9 0.9 0.9 0.4 0.4 0.3 0.0 0.0 0.3
## 10 0.6 0.6 0.7 0.6 0.5 0.5 0.4 0.3 0.3 0.0</code></pre>
<p>Now, we need to add the column and row names from the original data set, so that we know which animal is in which row.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">colnames</span>(mean_dists) &lt;-<span class="st"> </span><span class="kw">rownames</span>(animals)
<span class="kw">rownames</span>(mean_dists) &lt;-<span class="st"> </span><span class="kw">rownames</span>(animals)</code></pre></div>
<p>We are finally ready to plot a dendrogramm after clustering:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="kw">hclust</span>(<span class="kw">as.dist</span>(mean_dists)))</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>There seem to emerge three natural categories. One is dominated by the similarity between dog and cat (they have the same feature vectors), but bats and whales also belong there: the mammals. Then we have robin, canary and to a lesser degree ostrich: the birds. Finally, snake and lizzard, and the alligator: reptiles. Whale, bat and ostrich are rather unusual for their category, so they are bit further away from the other members. Obviously, the example by Knight is somewhat artifical, but in this sense it also my favorite “hello world” example for <em>artifical</em> neural networks.</p>
</div>
</div>
<div id="summary-and-restrictions" class="section level2">
<h2>Summary and Restrictions</h2>
<p>These examples show that leab<em>R</em>a seems to work fine for two typical use cases. Still, I cannot guarantee that the code is correct in every detail. Furthermore, there are some differences to the original C++ code. For instance, you cannot specify partial connections. Besides, the nxx1-function is a step-function to reduce calculation resources. Overall, the algorithm should still produce very similar results to the original Leabra implementation.</p>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<p>Knight, K. (1990). Connectionist ideas and algorithms. <em>Communications of the ACM</em>, <em>33</em>(11), 59–74.</p>
<p>O’Reilly, R. C., Munakata, Y., Frank, M. J., Hazy, T. E., and Contributors (2016). <em>Computational Cognitive Neuroscience</em>. Wiki Book, 3rd (partial) Edition. URL: <a href="http://ccnbook.colorado.edu" class="uri">http://ccnbook.colorado.edu</a></p>
<p>Rumelhart, D E., Hinton, G. E., &amp; Williams, R. J. (1986). Learning representations by back-propagating errors. <em>Nature</em>. <em>323</em>(6088): 533–536. <a href="doi:10.1038/323533a0" class="uri">doi:10.1038/323533a0</a>.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
